> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.csdn.net](https://blog.csdn.net/qq_34556414/article/details/125988271) host-gw 模式相比 vxlan 简单了许多，直接添加路由，将目的主机当做网关，直接路由原始封包

![](https://i-blog.csdnimg.cn/blog_migrate/bd72ef1a8236d5e6245b4532c89d52c7.png)

没有隧道这一说了，它们之间就是通过原始的数据包进行封装的。当你设置 flannel 使用 host-gw 模式，flanneld 会在宿主机上创建节点的路由表：

```
# ip route
default via 192.168.31.1 dev ens33 proto static metric 100
10.244.0.0/24 dev cni0 proto kernel scope link src 10.244.0.1
10.244.1.0/24 via 192.168.31.63 dev ens33
10.244.2.0/24 via 192.168.31.61 dev ens33
192.168.31.0/24 dev ens33 proto kernel scope link src 192.168.31.62 metric 100
```

目的 IP 地址属于 10.244.1.0/24 网段的 IP 包，应该经过本机的 ens33 设备发出去。并且它下一跳地址是 192.168.31.63（即：via 192.168.31.63）。

一旦配置了下一跳地址，那么接下来，当 IP 包从网络层进入链路层封装成帧的时候，eth0 设备就会使用下一跳地址对应的 MAC 地址，作为该数据帧的目的 MAC 地址。

而 Node 2 的内核网络栈从二层数据帧里拿到 IP 包后，会 “看到” 这个 IP 包的目的 IP 地址是 10.244.1.20，即 container-2 的 IP 地址。这时候，根据 Node 2 上的路由表，该目的地址会匹配到第二条路由规则（也就是 10.244.1.0 对应的路由规则），从而进入 cni0 网桥，进而进入到 container-2 当中。

可见，数据包是封装成帧发送出去的，会使用路由表的下一跳来设置目的 MAC 地址，会经过二层网络到达目的节点，因此，host gw 模式必须要求集群宿主机之间二层连通。

跨界点通信就意味着将数据包发送给上层的路由器，要看数据包的源 ip 和目标 ip 进行转发，源 ip 和目标 ip 为 pod 容器的 ip，上面的路由器肯定是不认识的，因为没有学习 k8s 里面的网络，所以直接就给丢弃了。

---------------------------------------------------------------------------------------------------------------------------------

在上述的 VXLAN 的示例中，Node1 和 Node2 其实是同一宿主机中的两台使用桥接模式的虚机，也就是说它们在一个二层网络中。在二层网络互通的情况下，直接配置节点的三层路由即可互通，不需要使用 VXLAN 隧道。要使用 host-gw 模式，需要修改 ConfigMap kube-flannel-cfg ，将 Backend.Type 从 vxlan 改为 host-gw，然后重启所有 kube-flannel Pod 即可：

```
...
  net-conf.json: |
    {
      "Network": "10.244.0.0/16",
      "Backend": {
        "Type": "host-gw" // <- 改成host-gw
      }
    }
 ...

```

host-gw 模式下的通信过程如下图所示：

![](https://i-blog.csdnimg.cn/blog_migrate/8c48538e9497d3ce6e830333c013c143.png)

在 host-gw 模式下，由于不涉及 VXLAN 的封包解包，不再需要 flannel.1 虚机网卡。flanneld 负责为各节点设置路由 ，将对应节点 Pod 子网的下一跳地址指向对应的节点的 IP，如图中路由表①所示。

```
...10.244.0.0/24 dev cni0 proto kernel scope link src 10.244.0.1
10.244.1.0/24 via 192.168.50.3 dev eth0 # Node2子网的下一跳地址指向Node2的public ip。
...

```

由于没有封包解包带来的消耗，host-gw 是性能最好的。不过一般在云环境下，都不支持使用 host-gw 的模式，在私有化部署的场景下，可以考虑。

---------------------------------------------------------------------------------------------------------------------------- 

#### HOST-GW 模式

与 UDP 模式和 VXLAN 模式不同，HOST-GW 模式属于路由的方式，无需经过任何封包和解包，纯路由机制实现，因此性能比较高。但是 HOST-GW 模式只支持宿主机之间二层连接，要求集群中所以节点必须处于同一个网络中。如果不在一个网络中，三层设备路由器缺少 Pod 网络的路由规则，无法转发数据包。

HOST-GW 模式将目的主机当作网关，直接路由原始的数据包。flanneld 会在集群节点上创建并维护路由表，当数据包到达集群节点的时，就会根据路由表直接发送到下一跳，也就是同网段的节点 IP，直接通过二层网络将数据转发到目的节点上；目的节点再根据路由表规则转发到 cni 网桥，网桥根据路由规则转发到容器里面。

HOST-GW 模式通过路由转发实现高性能网络通信，但是这种模式局限性很大，节点之间都要相互有点对点的路由覆盖，每个节点上有 n-1 个路由，而 n 个节点共有 n(n-1)/2 个路由，才能保证 flannel 的 flat 网络能力。

### **K8s 网络组件之 Flannel：小结**

* * *

**VXLAN 特点：**

• 先进行二层帧封装，再通过宿主机网络封装，解封装也一样，所以增加性能开销

• 对宿主机网络要求低，只要三层网络可达

**Host-GW 特点：**

• 直接路由转发，性能损失很小

• 对宿主机网络要求二层可达